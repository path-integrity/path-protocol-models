/*
 *  Author: Anonymous
 *  Model Name: chaum
 *  Comment: Model of path integrity for a simple onion protocol in the style of Chaum
 */

theory chaum  

begin

builtins: multiset

functions: aenc/2
           , adec/2
           , pk/1
           , sign/2
           , verify/3
           , true/0
           , Wrapped/1 [private] // Used to mitigate partial sources
equations: adec(aenc(m, pk(x)), x) = m,
           verify(sign(m, k), m, pk(k)) = true

/*
  We adopt the following syntax throughout:

  Fact Naming Conventions:
    - Standard facts are Capitalised
    - Facts used as part of a restriction
        (whether event or linear) are FULLCAPS
    - (Event) facts used only as part of helper or check lemmas
        are ended with Suffixes__()

  Usage:
    - We recommend use of an oracle file, command e.g.:
      time tamarin-prover\
        simpleOnion.spthy\
        --heuristic=O --oraclename=pi-oracle.py\
        --prove +RTS -N6 -RTS
    
    - For interactive mode:
        tamarin-prover interactive\
          simpleOnion.spthy\
          --heuristic=O --oraclename=pi-oracle.py\
          +RTS -N6 -RTS
    
    - Where N6 is the number of cores to be used

*/

// ******************************************* //
// ------------- Protocol Rules -------------- //
// ******************************************* //

// ---------------------------- //
// - Boundedness Restrictions - //
// ---------------------------- //
// This rule assigns "tokens" to be used by most other rules
// This ensures that certain steps can only run a certain number
// of times, and thus bounds our analysis.

rule Bound_Tokens:
  [  ]
--[
    ONCE('bounds')
  ]->
  [
    // 4 agents
    LTK_COUNTER('1')
    // 1 session
    , CREATE_TOKEN()
    , SEND_TOKEN()
    , RECEIVE_TOKEN()
    // 3 intermediates
    , WRAP_COUNTER('1')
    , UNWRAP_COUNTER('1')
  ]

// ---------------------------- //
// ----------- Setup ---------- //
// ---------------------------- //

rule Gen_Ltk [colour=ffffff]:  
  [
    Fr(~ltk) 
    , LTK_COUNTER(pre)
  ]
--[
    ONCE(<'key', $A>)
    , ENFORCE_LTK_COUNTER(pre)
  ]->
  [ 
    Out(pk(~ltk))
    , !Ltk($A, ~ltk)
    , !Pk($A, pk(~ltk))
    , LTK_COUNTER(pre+'1')
  ]


// ---------------------------- //
// -------- Corruption -------- //
// ---------------------------- //

// Replaces traditional unwrap rule for corrupt agents
rule Unwrap_Corrupt [colour=ffaaaa]:
  let
    before = aenc(after, pk(ltkM))
  in
  [
    In(Wrapped(before))
    , !Ltk($M, ltkM)
    , UNWRAP_COUNTER(pre)
  ]
--[
    Forward($M, before, after)
    , ENFORCE_UNWRAP_COUNTER(pre)
    , Corrupt($M)
  ]->
  [
    Out(Wrapped(after))
    , UNWRAP_COUNTER(pre+'1')
    , Out(<Wrapped(before), Wrapped(after)>)
  ]


// ---------------------------- //
// ------- Construction ------- //
// ---------------------------- //

rule Create [colour=8888ff]:
  let
    sig = sign(~p, ltkA)
    msg = <~p, sig>
    encmsg = aenc(msg, pkE)
  in
  [
    CREATE_TOKEN()
    , Fr(~p)
    , !Pk($E, pkE)
    , !Ltk($A, ltkA)
  ]
--[
    StartBuild($A, ~p)
    , Add(~p, $E, encmsg, 'fin')
    , ADD_AGENT(~p, $E)
  ]->
  [
    Build(~p, $E, encmsg)
  ]

// Note after and before are "swapped" in the Add fact
// This is because they represent what the initiating agent
// believes the message will change from and to
// i.e. the forwarding agent will reverse this encryption
rule Wrap [colour=9999ff]:
  let
    after = aenc(before, pkM)
  in
  [
     WRAP_COUNTER(pre)
    , Build(~p, $N, before)
    , !Pk($M, pkM)
  ]
--[
    Add(~p, $M, after, before)
    , ENFORCE_WRAP_COUNTER(pre)
    , ADD_AGENT(~p, $M)
  ]->
  [
    Build(~p, $M, after),
    WRAP_COUNTER(pre+'1')
  ]

rule Send [colour=aaaaff]:
  [
    Build(~p, $M, message)
    , SEND_TOKEN()
  ]
--[
  ]->
  [
    Out(Wrapped(message))
  ]

// ---------------------------- //
// -------- Forwarding -------- //
// ---------------------------- //

rule Unwrap [colour=aaffaa]:
  let
    before = aenc(after, pk(ltkM))
  in
  [
    In(Wrapped(before))
    , !Ltk($M, ltkM)
    , UNWRAP_COUNTER(pre)
  ]
--[
    Forward($M, before, after)
    , ENFORCE_UNWRAP_COUNTER(pre)
  ]->
  [
    Out(Wrapped(after))
    , UNWRAP_COUNTER(pre+'1')
  ]

// ---------------------------- //
// --------- Receive ---------- //
// ---------------------------- //

rule Receive[colour=aaffaa]:
  let
    msg = <p, sig>
    before = aenc(msg, pk(ltkE))
  in
  [
    RECEIVE_TOKEN()
    , In(Wrapped(before))
    , !Ltk($E, ltkE)
    , !Pk($A, pkA)
  ]
--[
    EQUAL(verify(sig, p, pkA), true)
    , Forward($E, before, 'fin')
    , Reachable__()
  ]->
  [

  ]


// ******************************************* //
// --------- Restrictions and Lemmas --------- //
// ******************************************* //

// ---------------------------- //
// ------- Restrictions ------- //
// ---------------------------- //

// One key per person, one token allocation
restriction once:
"
  All type #t1 #t2.
    ONCE(type)@t1 &
    ONCE(type)@t2
  ==>
    (#t1 = #t2)
"

// Agents not repeated on path
restriction pathOrderWellFormed:
"
  All pid A #ta #tb.
    ADD_AGENT(pid, A)@ta &
    ADD_AGENT(pid, A)@tb
  ==>
    (#ta = #tb)
"

// Equality (e.g. in signature schemes)
restriction equal:
"
  All l r #t.
    EQUAL(l, r)@t ==> l = r
"

// The counter starts at '1'
// This is a pre-check (it is incremented as part of the rule)
// So this restriction will prevent the fifth call to Gen_Ltk
restriction ltk_counter:
"
  All counter #t.
    ENFORCE_LTK_COUNTER(counter)@t
  ==>
  Ex z. counter + z = '1'+'1'+'1'+'1'//+'1'
"

// The counter starts at '1'
// This is a pre-check (it is incremented as part of the rule)
// So this restriction will prevent the fourth call to Wrap
restriction wrap_counter:
"
  All counter #t.
    ENFORCE_WRAP_COUNTER(counter)@t
  ==>
  Ex z. counter + z = '1'+'1'+'1'//+'1'
"

// The counter starts at '1'
// This is a pre-check (it is incremented as part of the rule)
// So this restriction will prevent the fourth call to Forward
restriction unwrap_counter:
"
  All counter #t.
    ENFORCE_UNWRAP_COUNTER(counter)@t
  ==>
  Ex z. counter + z = '1'+'1'+'1'//+'1'
"

// ---------------------------- //
// ------- Sanity Lemmas ------ //
// ---------------------------- //

lemma reachable:
exists-trace
"
  Ex #t. Reachable__()@t
"

// ---------------------------- //
// ------ Security Lemmas ----- //
// ---------------------------- //

lemma path_integrity:
all-traces
"
  All A Mi Mj pid // Agents
    fi ti fj tj // From- and to- terms
    #tai #taj #tki #ts. // times
  
  StartBuild(A, pid)@ts
  & Add(pid, Mi, fi, ti)@tai
  & Add(pid, Mj, fj, tj)@taj
  // A is not corrupt?
  & (#tai < taj) // Path order established
  & (
      ( Forward(Mi, fi, ti)@tki ) // Mi forwarded the message properly
    )
  ==> 
  ( // Either
    ( Ex #tkj.
        (#tkj < #tki)
      &  Forward(Mj, fj, tj)@tkj 
    ) | // Mj forwarded the message properly
    ( // Mj is corrupt and the adversary readily could have forwarded
      Ex #tkj #tcj.
        (#tkj < #tki)
        & Corrupt(Mj)@tcj
        & K(<Wrapped(fj), Wrapped(tj)>)@tkj
    )      
  )

"

end